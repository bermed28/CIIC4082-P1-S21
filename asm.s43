#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Digits to represent
digitH  db             0xFC, 0x60, 0xdb, 0xf1, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
digitL  db              0x28,   0,    0,    0,    0,    0,    0,    0,    0,   0
result  db               0,0,0,0,0,0,0 ;added another zero
        ALIGN 1

;Addresses for LCD Segments
segmentsHi        dw  0x0A29, 0x0A25, 0x0A23, 0x0A32, 0x0A2E, 0x0A27
segmentsL         dw  0x0A2A, 0x0A26, 0x0A24, 0x0A33, 0x0A2F, 0x0A28

;Operators to represent
;+ = 0
;- = 1
;/ = 2
;* = 3
operatorsHi db 0x03, 0x03, 0x00, 0x03 ; High Bytes Table
operatorsLo db 0x50,   0,  0x28, 0xFA ; Low Bytes Table

;State handler
state   db      0

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack200/


SetupPorts:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default

                mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input
                mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
                bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as pull down
        bic.b   #0x01,&P1OUT            ; Clear P1.0 and P9.7 output latch to

UnlockGPIO:                           ;DIsbale GPIO power-on default
        bic.w   #LOCKLPM5, &PM5CTL0   ; high-impedance mode to activate
                                      ; previously configured port settings

        ;Enable LCD Segments 0 - 2; 26-43

        MOV.W   #0xffff, &LCDCPCTL0
        MOV.W   #0xfc3f, &LCDCPCTL1
        MOV.W   #0x0fff, &LCDCPCTL2

        MOV.W   #0x041e, &LCDCCTL0 ;Bin number to set up bits to control LCD and initialize

        MOV.W   #0x0208,&LCDCVCTL  ;VLCD generated interally, V2-V4 gen interlan, V5 to ground, set VLCD to 2.60v, enabled charge pump and select reference
        MOV.W   #0x8000,&LCDCCPCTL ;clock synch enabled

        MOV.W   #2,&LCDCMEMCTL  ;clear LCD memory

        BIS.W   #1, &LCDCCTL0 ; Turn on LCD

        MOV.W   #2,&LCDCMEMCTL  ;clear LCD memory

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

startSystem:
        MOV.W   #2,&LCDCMEMCTL  ;clear LCD memory
        mov    #0xFFFF, R10
        MOV.B  #0, R5          ; track index of digit selected
        MOV.B  #0, R4          ; track which button is pressed
        MOV.B  #0, R14         ; track index of segment array

        MOV.B  #0x0099, R13          ; Registro utilizado para verificar cual de las
                                 ; subrutinas aritmeticas seran invocadas. #99 indica que no se ha escogido una operacion

        MOV.W  #0, R12          ; Registro donde se guardara el valor del primer numero
        MOV.W  #0, R11          ; Registro donde se guardara el segundo numero
        MOV.W  #0, R9           ; Registro donde se guardara el resultado
        MOV.B  #0, R8           ; indica cual de los 3 estados de la aplicacion esta
        MOV.B  #0, R7



initialValue:
         CMP.b  #1,r8
         JEQ    operator
         cmp.b  #4, R8
         JEQ    MainCheckState
         jmp    zero



zero:
         push   R6            ;To restore default value
         push   R7            ;To restore default value later

         MOV.w    #segmentsHi, R6 ;Store beginning address of segments in R6
         MOV.w    #segmentsL, R7 ;Store beginning address of segmentsLo in R7

         add.w    R14, R6       ;Add the index everytime to position ourselves in correct segment
         add.w    R14, R7

         mov.w    0(R6),  R6    ;Move that value (segment) and store it in R6
         mov.w    0(R7),  R7    ;Same for R7

         MOV.B  digitH(R5), 0(R6)       ;Draw digit at said segment
         MOV.B  digitL(R5), 0(R7)

         pop    R7 ;restore
         pop    R6 ;restore
         ;INC    R5
         jmp    MainCheckState



operator:
         push   R6            ;To restore default value
         push   R7            ;To restore default value later

         MOV.w    #segmentsHi, R6 ;Store beginning address of segments in R6
         MOV.w    #segmentsL, R7 ;Store beginning address of segmentsLo in R7

         add.w    R14, R6       ;Add the index everytime to position ourselves in correct segment
         add.w    R14, R7

         mov.w    0(R6),  R6    ;Move that value (segment) and store it in R6
         mov.w    0(R7),  R7    ;Same for R7

         MOV.B operatorsHi(R5), 0(R6)       ;Draw digit at said segment
         MOV.B operatorsLo(R5), 0(R7)

         pop    R7 ;restore
         pop    R6 ;restore
         ;INC    R5
         jmp    MainCheckState


MainCheckState:
         CMP.B  #0, R8
         JEQ    calc
         CMP.B  #1, R8
         JEQ    arthmloop
         CMP.B  #2, R8
         JEQ    calc
         CMP.B  #3, R8
         JEQ    showResult
         CMP.B  #4, R8
         JEQ    startSystem ;Clean everything to restart operations

calc:
         MOV.B  &P1IN,R4        ;Reads if one of the pins have been pressed
         call   #delay
         and.b  #00000110B,R4
         CMP.B  #4,R4           ;Left button pressed.
         JEQ    startIncNum     ;Increase the number in current segment
         CMP.B  #2,R4           ;Right button is pressed.
         JEQ    startChangeSegment   ;Change segment to the right
         JMP    calc

checkDigit:

         CMP.B  #9, R5
         JEQ    resetIndex              ;Reset index if we're at 9 so that we can loop from 0-9
         INC    R5                      ;Increase digit index
         ret

;Objetivo: Llamar incNum
;Precondiciones: Estar en el estado 0 o 2
;Postcondiciones: No hay
;Autor: Jose Biescas
;Fecha: 3/13/2021
startIncNum:

         call   #checkDigit

         call   #incNum

         jmp    calc

;Objetivo: Dibujar los Hi and Lo bytes de los digitos en el segmento correspondiente
;Precondiciones: R14 contiene el segmento en donde se van a dibujar los digitos, R5 contiene el indice del digito a dibujar
;Postcondiciones: Los registros R6 y R7 no tendran efectos secundarios. El registro R5 no debe ser afectado por los otros estados del programa
;Autor: Jose Biescas
;Fecha: 3/11/2021
incNum:

         push   R6            ;To restore default value
         push   R7            ;To restore default value later

         MOV.w    #segmentsHi, R6 ;Store beginning address of segments in R6
         MOV.w    #segmentsL, R7 ;Store beginning address of segmentsLo in R7

         add.w    R14, R6       ;Add the index everytime to position ourselves in correct segment
         add.w    R14, R7

         mov.w    0(R6),  R6    ;Move that value (segment) and store it in R6
         mov.w    0(R7),  R7    ;Same for R7

         MOV.B  digitH(R5), 0(R6)       ;Draw digit at said segment
         MOV.B  digitL(R5), 0(R7)

         pop    R7 ;restore
         pop    R6 ;restore

         ret
;Objetivo: Re-iniciar el indice de R5, para eso de volver a 0 despues de llegar al 9, o volver a '+' despues de llegar a '*'
;Precondiciones:
;Postcondiciones:
;Autor: Jose Biescas
;Fecha: 3/13/2021
resetIndex:
         mov.b  #0, R5
         jmp    return


;Objetivo: Llamar changeSegment
;Precondiciones: Estar en el estado 0, 1, o 2
;Postcondiciones: No hay
;Autor: Jose Biescas
;Fecha: 3/13/2021
startChangeSegment:


         call   #translateLCD
         call   #changeSegment

         jmp    initialValue

;Objetivo: Incrementar el registro R14, para indicar el indice actual y se re-inicia el indice de los digitos/operadores
;Precondiciones: El boton derecho se debio tocar, solamente se llama si no estamos al final de los 3 digitos, o si escogimos operador
;Postcondiciones:
;Autor: Jose Biescas
;Fecha: 3/11/2021
changeSegment:
         CMP.B  #4, R14
         JEQ    changeState
         INCD.W    R14             ;Increase segment index
         MOV.B  #0, R5          ;Reset digit index


         ret

;el primer segmento se multiplicara por 100, el segundo por 10 y el primero sumamos
;se realizara cada vez que se escribe un numero
;el estado de la applicacion nos indica en que registro guardar el valor

translateLCD:
        mov R5, R6
        ;dec r6
        cmp.b  #3, R8
        jeq    retu
        cmp.b  #4, R8
        jeq    retu
        CMP.B  #0, R14
        jeq    addH
        CMP.B  #2, R14
        jeq    addD
        CMP.B  #4, R14
        jeq    addU


retu:
        nop
        ret

addH:
        cmp.b #0, R8
        jeq   addfvH
        cmp.b #2, R8
        jeq   addsvH


addfvH:
        cmp.b #0, R6
        jeq   retu
        add   #100, R12
        dec   R6
        jmp   addfvH

addsvH:
        cmp.b #0, R6
        jeq   retu
        add   #100, R11
        dec   R6
        jmp   addsvH


addD:

        cmp.b #0, R8
        jeq   addfvD
        cmp.b #2, R8
        jeq   addsvD

addfvD:
        cmp.b #0, R6
        jeq   retu
        add   #10, R12
        dec   R6
        jmp   addfvD

addsvD:

        cmp.b #0, R6
        jeq   retu
        add   #10, R11
        dec   R6
        jmp   addsvD
addU:

        cmp.b #0, R8
        jeq   addfvU
        cmp.b #2, R8
        jeq   addsvU

addfvU:
        add   R6, R12
        jmp retu

addsvU:
        add   R6, R11
        jmp return


;TODO
;Objetivo: Incrementar el registro R14, para indicar el indice actual y se re-inicia el indice de los digitos/operadores
;Precondiciones: El boton derecho se debio tocar, solamente se llama si no estamos al final de los 3 digitos, o si escogimos operador
;Postcondiciones:
;Autor: Guillermo Betancourt
;Fecha: 3/13/2021
changeState:
       call     #delay
       inc.B R8
       mov.b #0, R5
       mov.b #0, R14
       MOV.W #2,&LCDCMEMCTL  ;clear LCD memory

       jmp initialValue


; We make a seperate loop to get the arthm values until button pressed
;Guillermo
arthmloop:
        MOV.B  #0, R4
        MOV.B  &P1IN,R4        ;Reads if one of the pins have been pressed
        call   #delay
        and.b  #00000110B,R4
        CMP.B  #4,R4           ;Left button pressed.
        JEQ    startChangeOperator
        CMP.B  #2,R4           ;Right button is pressed
        JEQ    setOp
        JMP    arthmloop


checkOperator:
         CMP.B  #3, R5
         JEQ    resetIndex              ;Reset index if we're at '*'
         INC    R5
         ret

;choose arthm op
setOp:
        MOV.B   operatorsLo(R5), R13
        CMP.B   #0x0099, R13
        JEQ     arthmloop
        jmp changeState

startChangeOperator:
        call    #checkOperator
        call    #changeOperator

        jmp     arthmloop



;Objetivo: Dibujar los simbolos de las operaciones en el primer segmento del LCD
;Precondiciones: R14 debe ser 0, R5 contiene el indice del operador a dibujar
;Postcondiciones: Los registros R6 y R7 no tendran efectos secundarios. El registro R5 no debe ser afectado por los otros estados del programa
;Autor: Jose Biescas
;Fecha: 3/13/2021
changeOperator:
         push   R6
         push   R7

         MOV.w    #segmentsHi,   R6
         MOV.w    #segmentsL,   R7
         add.w    R14, R6
         add.w    R14, R7

         mov.w    0(R6), R6
         mov.w    0(R7), R7

         MOV.B  operatorsHi(R5), 0(R6)
         MOV.B  operatorsLo(R5), 0(R7)

         pop    R7
         pop    R6

         ret

showResult:
;we have to show value and reset registers
;we would verify R13 to check which op
         CMP.B  #0x50, R13
         JEQ    addition
         CMP.B  #0, R13
         JEQ    substraction
         CMP.B  #0x28, R13
         JEQ    division
         CMP.B  #0xFA, R13
         JEQ    multiplication
         jmp    showNumber

showNumber:
       mov.b    #0, R6                  ;R6: arreglo de digitos
       call     #extractDigits
       call     #extractZeros
       mov.w    R10, R9
       call     #extractDigits

       mov      #0, R14
       jmp      display

;Objetivo:  Añadir 0s al arreglo de digitos result de no tener suficientes digitos.
;Precondiciones: R6 es el numero de digitos en result.
;Postcondiciones: El registro R6 sera 4 y habran 4 digitos en results.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
extractZeros:
       cmp.b   #4, R6
       jl      keepExtractingZeros
       ret

;Objetivo:  Añadir 0s hasta que R6 llegue a 4.
;Precondiciones: R6 es el numero de digitos en result.
;Postcondiciones: El registro R6 sera 4 y habran 4 digitos en results.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
keepExtractingZeros:
       inc     R6
       mov.b   #0, result(R6)
       cmp.b   #4, R6
       jl      keepExtractingZeros
       ret

display:
         push   R4
         push   R9

         MOV.w      #result, R7
         Add.w      R6, R7

         MOV.w    #segmentsHi,  R4
         MOV.w    #segmentsL,   R9
         add.w    R14, R4
         add.w    R14, R9
         mov.b    0(R7), R7
         mov.w    0(R4), R4
         mov.w    0(R9), R9

         MOV.B  digitH(R7), 0(R4)
         MOV.B  digitL(R7), 0(R9)

         pop    R9
         pop    R4


         dec    R6
         incd   R14
         cmp    #1, R6
         jge    display

         jmp    restartLoop



addition:
        push    R11
        add R12, R11
        mov r11, r9
        pop     R11
        jmp showNumber

substraction:
        push    R11
        sub.w     R12, R11
        mov     r11, r9
        pop     R11
        jmp showNumber


multiplication:
        push    R11
        push    R12
        cmp.w   R11, R12
        jn      swapSmallest            ;If R11 > R12, we swap the registers values
        mov.w   #0x0, R9                ;Set our result to 0
        mov.w   #0x0, R10               ;Set our overflow result to 0
        jmp     start


start:
        ;Approach, sum number x (R12) a y (R11) amount of times to get multiplication
        ;Example: 200 * 3 = sum 200 a total amount of 3 times

        add.w   R12, R9                 ; We use R9 to store our result
        cmp.w   #0x2710, R9
        jge     addOverflow
        //adc.w   R10                      ; Add carry for numbers > 16 bits
        dec     R11                     ; Decrement our counter
        jz      finishM                  ; If we finished sum, return
        jmp     start                   ; If not, continue

;Objetivo: Guardar los primeros 2 digitos del resultado si tiene 6 digitos
;Precondiciones: R10 contiene la cantidad de 10,000s que contiene el resultado, R9 es el conteo hasta 10,000
;Postcondiciones: //Los registros R10 y R9 no tendran efectos secundarios. El registro R11 no debe ser afectado por los otros estados del programa
;Autor: Verónica Bernier
;Fecha: 3/15/2021
addOverflow:
        inc     R10
        sub.w   #0x2710, R9
        //inc     R9
        dec     R11
        jz      finishM
        jmp     start

swapSmallest:

        mov.w   R11, R9                 ; temp (R9) = R11
        mov.w   R12, R11                ; R11 = R12
        mov.w   R9, R12                 ; R12 = temp
        mov.w   #0x0, R9                ; Reset result to 0
        mov.w   #0x0, R10               ; Set our overflow result to 0
        jmp     start


finishM:
        pop    R12
        pop    R11
        jmp showNumber

;Objetivo: Guardar la division de R12 entre R11 en R9 luego de validar que R11 no sea 0.
;Precondiciones: R12 contiene lel primer valor y R11 el segundo
;Postcondiciones: Los registros R11 y R12 no tendran efectos secundarios. El registro R9 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/12/2021
division:
        cmp.w   #1, R11
        jge     startDivision
        jmp     showNumber

;Objetivo: Comenzar el proceso de division entre R11 y R12
;Precondiciones: R12 contiene el primer valor y R11 el segundo. R9 incrementa con cada brinco.
;Postcondiciones: Los registros R11 y R12 no tendran efectos secundarios. El registro R9 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/12/2021
startDivision:
        push    R12                     ;we'll manipulate R12 (R12 / R11)
        mov.w   #0, R9                   ;R9 returns the coecient (result)
        sub.w   R11, R12
        cmp.w   #0, R12
        JGE     keepSubstracting
        pop     R12                      ;restore value
        jmp     showNumber

;Objetivo: Restar R11 a R12 hasta llegar a un valor negativo.
;Precondiciones: R12 contiene el primer valor y R11 el segundo. R9 incrementa con cada brinco.
;Postcondiciones: Los registros R11 y R12 no tendran efectos secundarios. El registro R9 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/12/2021
keepSubstracting:
        inc     R9
        sub.w   R11, R12
        cmp.w   #0, R12
        JGE     keepSubstracting
        pop     R12                      ;restore value
        jmp     showNumber

;Objetivo: Dado un valor, extraer cada digito en decimal.
;Precondiciones: R9 contiene el valor original. R6 se usa como arreglo.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R6 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
extractDigits:
                        ;R7 contiene el valor completo
        push R9
        //mov.b   #0, R6                  ;R6: arreglo de digitos
        jmp     keepExtracting

;Objetivo: Dado un valor, extraer cada digito en decimal.
;Precondiciones: R9 contiene el valor original. R6 se usa como arreglo.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R6 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
keepExtracting:
        call    #module10
        inc     R6
        mov.b   R7, result(R6)
        call    #division10
        mov.w   R7, R9
        cmp.w   #1, R9
        JGE     keepExtracting
        pop     R9
        ret

;Objetivo: Dividir el valor en el registro R9 por 10.
;Precondiciones: R9 contiene el valor original. R7 se usa temporalmente.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R7 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
division10:
        push    R9                       ;we'll manipulate R9 (R9 / 10)
        mov.w   #0, R7                   ;R7 returns the coecient (result)
        sub.w   #10, R9
        cmp.w   #0, R9
        JGE     keepSubstractingDiv10
        pop     R9                      ;restore value
        ret

;Objetivo: Restar  10 al valor en el registro R9 hasta que sea negativo.
;Precondiciones: R9 contiene el valor original. R7 se usa temporalmente.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R7 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
keepSubstractingDiv10:
        inc     R7
        sub.w   #10, R9
        cmp.w   #0, R9
        JGE     keepSubstractingDiv10
        pop     R9                      ;restore value
        ret

;Objetivo: Encontrar el residuo de R9 mod 10
;Precondiciones: R9 contiene el valor original. R7 se usa temporalmente.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R7 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
module10:
        push    R9                       ;we'll manipulate R9(R9 mod 10)
        sub.w   #10, R9
        cmp.w   #0, R9
        JGE     keepSubstractingMod10
        add.w   #10, R9
        mov.w   R9, R7                  ;R7 returns the "residuo" (result)
        pop     R9                      ;restore value
        ret

;Objetivo: Restar  10 al valor en el registro R9 hasta que sea negativo y devolver el residuo en R7.
;Precondiciones: R9 contiene el valor original. R7 se usa temporalmente.
;Postcondiciones: El registro R9 no tendra efectos secundarios. El registro R7 sera alterado.
;Autor: Verónica Bernier
;Fecha: 3/14/2021
keepSubstractingMod10:
        sub.w   #10, R9
        cmp.w   #0, R9
        JGE     keepSubstractingMod10
        add.w   #10, R9
        mov.w   R9, R7                  ;R7 returns the "residuo" (result)
        pop     R9                      ;restore value
        ret

restartLoop:
        MOV.B  &P1IN,R4        ;Reads if one of the pins have been pressed
        call   #delay
        and.b  #00000110B,R4
        CMP.B  #2,R4           ;Right button is pressed.
        JEQ    changeState   ;Change segment to the right
        JMP    restartLoop

return:
        ret

delay:
         mov    #0xFFFF, R10
next:
         dec    R10
         jnz    next
         ret

        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
