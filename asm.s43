#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        ORG     01c00h

;Digits to represent   filler value simplifies sum
digitH  db              0xFC, 0x60, 0xdb, 0xf1, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
;size    db             6   we kinda dont need to waste cycles in memory cuando podemos hardcode it

;LCD Placement
segments db            0xa29, 0xa25, 0xa23, 0xa32, 0xa2e, 0xa27

;Operrations to be used
operations db        0x000, 0x000 , 0x000, 0x000
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


SetupPorts:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default

	      mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input
	      mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
	      bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as pull down
        bic.b   #0x01,&P1OUT            ; Clear P1.0 and P9.7 output latch to

        MOV.W   #0xffff, &LCDCPCTL0     ;Enable LCD Segments 0 - 2; 26-43
        MOV.W   #0xfc3f, &LCDCPCTL1
        MOV.W   #0x0fff, &LCDCPCTL2

        bic.w   #LOCKLPM5, &PM5CTL0   ; high-impedance mode to activate
                                      ; previously configured port settings

        MOV.W   #0x041e, &LCDCCTL0 ;Bin number to set up bits to control LCD and initialize

        MOV.W   #0x0208,&LCDCVCTL  ;VLCD generated interally, V2-V4 gen interlan, V5 to ground, set VLCD to 2.60v, enabled charge pump and select reference
        MOV.W   #0x8000,&LCDCCPCTL ;clock synch enabled

        MOV.W   #2,&LCDCMEMCTL  ;clear LCD memory

        BIS.W   #1, &LCDCCTL0 ; Turn on LCD

        MOV.W   #2,&LCDCMEMCTL  ;clear LCD memory




;For the logic of the project the numbers and arithmetic operations will be verified
;by storing the numerical value of the different characters shown in the lcd display

main:    NOP                             ; main program

         MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer


         mov    #0xFFFF, R10    ; used for Busy waiting due to lack of interrupts
         MOV.B  #0, R5          ; track index of digit selected
         MOV.B  #0, R4          ; track which button is pressed
         MOV.B  #0, R14         ; track index of segment array

        MOV.B  #0, R13          ; Registro utilizado para verificar cual de las
                                ; subrutinas aritmeticas seran invocadas

        MOV.B  #0, R12          ; Registro donde se guardara el valor del primer numero
        MOV.B  #0, R11          ; Registro donde se guardara el segundo numero
        MOV.W  #0, R9           ; Registro donde se guardara el resultado
        MOV.B  #0, R8           ; indica cual de los 3 estados de la aplicacion esta


calc:
         MOV.B  &P1IN,R4        ;Reads if one of the pins have been pressed
         call   #delay
         and.b  #00000110B,R4
         CMP.B  #4,R4           ;Left button pressed.
         JEQ    changeNum
         CMP.B  #2,R4           ;Right button is pressed
         JEQ    nextDigit
         JMP    calc


changeNum:
         MOV.B  digitH(R5), segments(R14)
         INC    R5
         call   #delay
         JMP    calc

delay:
         dec    R10
         jnz    delay
         mov    #0xFFFF, R10
         ret


nextDigit:
        ;verify if done
        CMP     #3,R8
        jeq     showResult

        ; verify if we have to show arthm
        cmp     #1, R8
        JEQ     arthmloop

        ; if not translate input value
        jmp     translateLCD



;el primer segmento se multiplicara por 100, el segundo por 10 y el primero sumamos
;se realizara cada vez que se escribe un numero
;el estado de la applicacion nos indica en que registro guardar el valor

translateLCD:
        CMP.B  #0, R14
        jeq    addH
        CMP.B  #1, R14
        jeq    addD
        CMP.B  #2, R14
        jeq    addU



addH:
        cmp.b #0, R8
        jeq   addfvH
        cmp.b #1, R8
        jeq   addsvH


addfvH:
        cmp.b #0, R5
        jeq   calc
        add.b   #100, R12
        dec   R5
        jmp   addfvH

addsvH:
        cmp.b #0, R5
        jeq   calc
        add.b   #100, R11
        dec   R5
        jmp   addsvH


addD:

        cmp.b #0, R8
        jeq   addfvD
        cmp.b #1, R8
        jeq   addsvD



addfvD:

        cmp.b #0, R5
        jeq   changeSegment
        add.b   #10, R12
        dec   R5
        jmp   addfvD

addsvD:

        cmp.b #0, R5
        jeq   changeSegment
        add.b   #10, R11
        dec   R5
        jmp   addsvD
addU:

        cmp.b #0, R8
        jeq   addfvU
        cmp.b #1, R8
        jeq   addsvU



addfvU:
        add.b   R5, R12
        jmp changeSegment

addsvU:
        add.b   R5, R11
        jmp changeSegment

;Change the segment to be written upon
changeSegment:
        inc     R14
        CMP     #3, R14       ; already wrote three times we change state to opr
        jeq    changeState

;We have to reset segment positioning and index value to iterate arthm op
changeState:
       inc R8
       mov.b #0, R5
       mov.b #0, R14
       jmp calc

showResult:
;we have to show value and reset registers
;we would verify R13 to check which op

; We make a seperate loop to get the arthm values until button pressed
arthmloop:
        MOV.B  &P1IN,R4        ;Reads if one of the pins have been pressed
        call   #delay
        and.b  #00000110B,R4
        CMP.B  #4,R4           ;Left button pressed.
        JEQ    changeOp
        CMP.B  #2,R4           ;Right button is pressed
        JEQ    setOp

;choose arthm op
setOp:
        mov.b  operations(R5), R13
        jmp changeState

;loop values
changeOp:
        cmp.b  #3,R5   ; verify if we have to reloop options
        jeq    resetOp
        MOV.B  operations(R5), segments(R14)
        INC    R5
        call   #delay
        JMP    arthmloop

;reset options
resetOp:

        mov #0, R5
        jmp changeOp




;dos:
;        MOV.W   #2, &LCDCMEMCTL
;        MOV.B   #5,R14
;        MOV.B   #0,R5
;        MOV.B   #0x60, 0x0a20(R14)
;        MOV.B   0x0a20(R14), R5


        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
